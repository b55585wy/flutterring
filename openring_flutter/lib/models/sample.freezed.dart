// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sample.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Sample _$SampleFromJson(Map<String, dynamic> json) {
  return _Sample.fromJson(json);
}

/// @nodoc
mixin _$Sample {
  int get timestamp => throw _privateConstructorUsedError; // PPG 通道（光电容积脉搏波）
  int get green => throw _privateConstructorUsedError;
  int get red => throw _privateConstructorUsedError;
  int get ir => throw _privateConstructorUsedError; // 加速度计通道
  int get accX => throw _privateConstructorUsedError;
  int get accY => throw _privateConstructorUsedError;
  int get accZ => throw _privateConstructorUsedError; // 陀螺仪通道
  int get gyroX => throw _privateConstructorUsedError;
  int get gyroY => throw _privateConstructorUsedError;
  int get gyroZ => throw _privateConstructorUsedError; // 温度通道
  int get temp0 => throw _privateConstructorUsedError;
  int get temp1 => throw _privateConstructorUsedError;
  int get temp2 => throw _privateConstructorUsedError;

  /// Serializes this Sample to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Sample
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SampleCopyWith<Sample> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SampleCopyWith<$Res> {
  factory $SampleCopyWith(Sample value, $Res Function(Sample) then) =
      _$SampleCopyWithImpl<$Res, Sample>;
  @useResult
  $Res call(
      {int timestamp,
      int green,
      int red,
      int ir,
      int accX,
      int accY,
      int accZ,
      int gyroX,
      int gyroY,
      int gyroZ,
      int temp0,
      int temp1,
      int temp2});
}

/// @nodoc
class _$SampleCopyWithImpl<$Res, $Val extends Sample>
    implements $SampleCopyWith<$Res> {
  _$SampleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Sample
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? timestamp = null,
    Object? green = null,
    Object? red = null,
    Object? ir = null,
    Object? accX = null,
    Object? accY = null,
    Object? accZ = null,
    Object? gyroX = null,
    Object? gyroY = null,
    Object? gyroZ = null,
    Object? temp0 = null,
    Object? temp1 = null,
    Object? temp2 = null,
  }) {
    return _then(_value.copyWith(
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      green: null == green
          ? _value.green
          : green // ignore: cast_nullable_to_non_nullable
              as int,
      red: null == red
          ? _value.red
          : red // ignore: cast_nullable_to_non_nullable
              as int,
      ir: null == ir
          ? _value.ir
          : ir // ignore: cast_nullable_to_non_nullable
              as int,
      accX: null == accX
          ? _value.accX
          : accX // ignore: cast_nullable_to_non_nullable
              as int,
      accY: null == accY
          ? _value.accY
          : accY // ignore: cast_nullable_to_non_nullable
              as int,
      accZ: null == accZ
          ? _value.accZ
          : accZ // ignore: cast_nullable_to_non_nullable
              as int,
      gyroX: null == gyroX
          ? _value.gyroX
          : gyroX // ignore: cast_nullable_to_non_nullable
              as int,
      gyroY: null == gyroY
          ? _value.gyroY
          : gyroY // ignore: cast_nullable_to_non_nullable
              as int,
      gyroZ: null == gyroZ
          ? _value.gyroZ
          : gyroZ // ignore: cast_nullable_to_non_nullable
              as int,
      temp0: null == temp0
          ? _value.temp0
          : temp0 // ignore: cast_nullable_to_non_nullable
              as int,
      temp1: null == temp1
          ? _value.temp1
          : temp1 // ignore: cast_nullable_to_non_nullable
              as int,
      temp2: null == temp2
          ? _value.temp2
          : temp2 // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SampleImplCopyWith<$Res> implements $SampleCopyWith<$Res> {
  factory _$$SampleImplCopyWith(
          _$SampleImpl value, $Res Function(_$SampleImpl) then) =
      __$$SampleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int timestamp,
      int green,
      int red,
      int ir,
      int accX,
      int accY,
      int accZ,
      int gyroX,
      int gyroY,
      int gyroZ,
      int temp0,
      int temp1,
      int temp2});
}

/// @nodoc
class __$$SampleImplCopyWithImpl<$Res>
    extends _$SampleCopyWithImpl<$Res, _$SampleImpl>
    implements _$$SampleImplCopyWith<$Res> {
  __$$SampleImplCopyWithImpl(
      _$SampleImpl _value, $Res Function(_$SampleImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sample
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? timestamp = null,
    Object? green = null,
    Object? red = null,
    Object? ir = null,
    Object? accX = null,
    Object? accY = null,
    Object? accZ = null,
    Object? gyroX = null,
    Object? gyroY = null,
    Object? gyroZ = null,
    Object? temp0 = null,
    Object? temp1 = null,
    Object? temp2 = null,
  }) {
    return _then(_$SampleImpl(
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      green: null == green
          ? _value.green
          : green // ignore: cast_nullable_to_non_nullable
              as int,
      red: null == red
          ? _value.red
          : red // ignore: cast_nullable_to_non_nullable
              as int,
      ir: null == ir
          ? _value.ir
          : ir // ignore: cast_nullable_to_non_nullable
              as int,
      accX: null == accX
          ? _value.accX
          : accX // ignore: cast_nullable_to_non_nullable
              as int,
      accY: null == accY
          ? _value.accY
          : accY // ignore: cast_nullable_to_non_nullable
              as int,
      accZ: null == accZ
          ? _value.accZ
          : accZ // ignore: cast_nullable_to_non_nullable
              as int,
      gyroX: null == gyroX
          ? _value.gyroX
          : gyroX // ignore: cast_nullable_to_non_nullable
              as int,
      gyroY: null == gyroY
          ? _value.gyroY
          : gyroY // ignore: cast_nullable_to_non_nullable
              as int,
      gyroZ: null == gyroZ
          ? _value.gyroZ
          : gyroZ // ignore: cast_nullable_to_non_nullable
              as int,
      temp0: null == temp0
          ? _value.temp0
          : temp0 // ignore: cast_nullable_to_non_nullable
              as int,
      temp1: null == temp1
          ? _value.temp1
          : temp1 // ignore: cast_nullable_to_non_nullable
              as int,
      temp2: null == temp2
          ? _value.temp2
          : temp2 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SampleImpl implements _Sample {
  const _$SampleImpl(
      {required this.timestamp,
      required this.green,
      required this.red,
      required this.ir,
      required this.accX,
      required this.accY,
      required this.accZ,
      required this.gyroX,
      required this.gyroY,
      required this.gyroZ,
      required this.temp0,
      required this.temp1,
      required this.temp2});

  factory _$SampleImpl.fromJson(Map<String, dynamic> json) =>
      _$$SampleImplFromJson(json);

  @override
  final int timestamp;
// PPG 通道（光电容积脉搏波）
  @override
  final int green;
  @override
  final int red;
  @override
  final int ir;
// 加速度计通道
  @override
  final int accX;
  @override
  final int accY;
  @override
  final int accZ;
// 陀螺仪通道
  @override
  final int gyroX;
  @override
  final int gyroY;
  @override
  final int gyroZ;
// 温度通道
  @override
  final int temp0;
  @override
  final int temp1;
  @override
  final int temp2;

  @override
  String toString() {
    return 'Sample(timestamp: $timestamp, green: $green, red: $red, ir: $ir, accX: $accX, accY: $accY, accZ: $accZ, gyroX: $gyroX, gyroY: $gyroY, gyroZ: $gyroZ, temp0: $temp0, temp1: $temp1, temp2: $temp2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleImpl &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.green, green) || other.green == green) &&
            (identical(other.red, red) || other.red == red) &&
            (identical(other.ir, ir) || other.ir == ir) &&
            (identical(other.accX, accX) || other.accX == accX) &&
            (identical(other.accY, accY) || other.accY == accY) &&
            (identical(other.accZ, accZ) || other.accZ == accZ) &&
            (identical(other.gyroX, gyroX) || other.gyroX == gyroX) &&
            (identical(other.gyroY, gyroY) || other.gyroY == gyroY) &&
            (identical(other.gyroZ, gyroZ) || other.gyroZ == gyroZ) &&
            (identical(other.temp0, temp0) || other.temp0 == temp0) &&
            (identical(other.temp1, temp1) || other.temp1 == temp1) &&
            (identical(other.temp2, temp2) || other.temp2 == temp2));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, timestamp, green, red, ir, accX,
      accY, accZ, gyroX, gyroY, gyroZ, temp0, temp1, temp2);

  /// Create a copy of Sample
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SampleImplCopyWith<_$SampleImpl> get copyWith =>
      __$$SampleImplCopyWithImpl<_$SampleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SampleImplToJson(
      this,
    );
  }
}

abstract class _Sample implements Sample {
  const factory _Sample(
      {required final int timestamp,
      required final int green,
      required final int red,
      required final int ir,
      required final int accX,
      required final int accY,
      required final int accZ,
      required final int gyroX,
      required final int gyroY,
      required final int gyroZ,
      required final int temp0,
      required final int temp1,
      required final int temp2}) = _$SampleImpl;

  factory _Sample.fromJson(Map<String, dynamic> json) = _$SampleImpl.fromJson;

  @override
  int get timestamp; // PPG 通道（光电容积脉搏波）
  @override
  int get green;
  @override
  int get red;
  @override
  int get ir; // 加速度计通道
  @override
  int get accX;
  @override
  int get accY;
  @override
  int get accZ; // 陀螺仪通道
  @override
  int get gyroX;
  @override
  int get gyroY;
  @override
  int get gyroZ; // 温度通道
  @override
  int get temp0;
  @override
  int get temp1;
  @override
  int get temp2;

  /// Create a copy of Sample
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SampleImplCopyWith<_$SampleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SampleBatch _$SampleBatchFromJson(Map<String, dynamic> json) {
  return _SampleBatch.fromJson(json);
}

/// @nodoc
mixin _$SampleBatch {
  List<Sample> get samples => throw _privateConstructorUsedError;
  int get timestamp => throw _privateConstructorUsedError;
  int? get sequenceNumber => throw _privateConstructorUsedError;

  /// Serializes this SampleBatch to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SampleBatch
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SampleBatchCopyWith<SampleBatch> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SampleBatchCopyWith<$Res> {
  factory $SampleBatchCopyWith(
          SampleBatch value, $Res Function(SampleBatch) then) =
      _$SampleBatchCopyWithImpl<$Res, SampleBatch>;
  @useResult
  $Res call({List<Sample> samples, int timestamp, int? sequenceNumber});
}

/// @nodoc
class _$SampleBatchCopyWithImpl<$Res, $Val extends SampleBatch>
    implements $SampleBatchCopyWith<$Res> {
  _$SampleBatchCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SampleBatch
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? samples = null,
    Object? timestamp = null,
    Object? sequenceNumber = freezed,
  }) {
    return _then(_value.copyWith(
      samples: null == samples
          ? _value.samples
          : samples // ignore: cast_nullable_to_non_nullable
              as List<Sample>,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      sequenceNumber: freezed == sequenceNumber
          ? _value.sequenceNumber
          : sequenceNumber // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SampleBatchImplCopyWith<$Res>
    implements $SampleBatchCopyWith<$Res> {
  factory _$$SampleBatchImplCopyWith(
          _$SampleBatchImpl value, $Res Function(_$SampleBatchImpl) then) =
      __$$SampleBatchImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Sample> samples, int timestamp, int? sequenceNumber});
}

/// @nodoc
class __$$SampleBatchImplCopyWithImpl<$Res>
    extends _$SampleBatchCopyWithImpl<$Res, _$SampleBatchImpl>
    implements _$$SampleBatchImplCopyWith<$Res> {
  __$$SampleBatchImplCopyWithImpl(
      _$SampleBatchImpl _value, $Res Function(_$SampleBatchImpl) _then)
      : super(_value, _then);

  /// Create a copy of SampleBatch
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? samples = null,
    Object? timestamp = null,
    Object? sequenceNumber = freezed,
  }) {
    return _then(_$SampleBatchImpl(
      samples: null == samples
          ? _value._samples
          : samples // ignore: cast_nullable_to_non_nullable
              as List<Sample>,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      sequenceNumber: freezed == sequenceNumber
          ? _value.sequenceNumber
          : sequenceNumber // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SampleBatchImpl implements _SampleBatch {
  const _$SampleBatchImpl(
      {required final List<Sample> samples,
      required this.timestamp,
      this.sequenceNumber})
      : _samples = samples;

  factory _$SampleBatchImpl.fromJson(Map<String, dynamic> json) =>
      _$$SampleBatchImplFromJson(json);

  final List<Sample> _samples;
  @override
  List<Sample> get samples {
    if (_samples is EqualUnmodifiableListView) return _samples;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_samples);
  }

  @override
  final int timestamp;
  @override
  final int? sequenceNumber;

  @override
  String toString() {
    return 'SampleBatch(samples: $samples, timestamp: $timestamp, sequenceNumber: $sequenceNumber)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleBatchImpl &&
            const DeepCollectionEquality().equals(other._samples, _samples) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.sequenceNumber, sequenceNumber) ||
                other.sequenceNumber == sequenceNumber));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_samples), timestamp, sequenceNumber);

  /// Create a copy of SampleBatch
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SampleBatchImplCopyWith<_$SampleBatchImpl> get copyWith =>
      __$$SampleBatchImplCopyWithImpl<_$SampleBatchImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SampleBatchImplToJson(
      this,
    );
  }
}

abstract class _SampleBatch implements SampleBatch {
  const factory _SampleBatch(
      {required final List<Sample> samples,
      required final int timestamp,
      final int? sequenceNumber}) = _$SampleBatchImpl;

  factory _SampleBatch.fromJson(Map<String, dynamic> json) =
      _$SampleBatchImpl.fromJson;

  @override
  List<Sample> get samples;
  @override
  int get timestamp;
  @override
  int? get sequenceNumber;

  /// Create a copy of SampleBatch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SampleBatchImplCopyWith<_$SampleBatchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

VitalSigns _$VitalSignsFromJson(Map<String, dynamic> json) {
  return _VitalSigns.fromJson(json);
}

/// @nodoc
mixin _$VitalSigns {
  int? get heartRate => throw _privateConstructorUsedError;
  int? get respiratoryRate => throw _privateConstructorUsedError;
  SignalQuality get quality => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;

  /// Serializes this VitalSigns to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of VitalSigns
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VitalSignsCopyWith<VitalSigns> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VitalSignsCopyWith<$Res> {
  factory $VitalSignsCopyWith(
          VitalSigns value, $Res Function(VitalSigns) then) =
      _$VitalSignsCopyWithImpl<$Res, VitalSigns>;
  @useResult
  $Res call(
      {int? heartRate,
      int? respiratoryRate,
      SignalQuality quality,
      DateTime timestamp});
}

/// @nodoc
class _$VitalSignsCopyWithImpl<$Res, $Val extends VitalSigns>
    implements $VitalSignsCopyWith<$Res> {
  _$VitalSignsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VitalSigns
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? heartRate = freezed,
    Object? respiratoryRate = freezed,
    Object? quality = null,
    Object? timestamp = null,
  }) {
    return _then(_value.copyWith(
      heartRate: freezed == heartRate
          ? _value.heartRate
          : heartRate // ignore: cast_nullable_to_non_nullable
              as int?,
      respiratoryRate: freezed == respiratoryRate
          ? _value.respiratoryRate
          : respiratoryRate // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as SignalQuality,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VitalSignsImplCopyWith<$Res>
    implements $VitalSignsCopyWith<$Res> {
  factory _$$VitalSignsImplCopyWith(
          _$VitalSignsImpl value, $Res Function(_$VitalSignsImpl) then) =
      __$$VitalSignsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? heartRate,
      int? respiratoryRate,
      SignalQuality quality,
      DateTime timestamp});
}

/// @nodoc
class __$$VitalSignsImplCopyWithImpl<$Res>
    extends _$VitalSignsCopyWithImpl<$Res, _$VitalSignsImpl>
    implements _$$VitalSignsImplCopyWith<$Res> {
  __$$VitalSignsImplCopyWithImpl(
      _$VitalSignsImpl _value, $Res Function(_$VitalSignsImpl) _then)
      : super(_value, _then);

  /// Create a copy of VitalSigns
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? heartRate = freezed,
    Object? respiratoryRate = freezed,
    Object? quality = null,
    Object? timestamp = null,
  }) {
    return _then(_$VitalSignsImpl(
      heartRate: freezed == heartRate
          ? _value.heartRate
          : heartRate // ignore: cast_nullable_to_non_nullable
              as int?,
      respiratoryRate: freezed == respiratoryRate
          ? _value.respiratoryRate
          : respiratoryRate // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as SignalQuality,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VitalSignsImpl implements _VitalSigns {
  const _$VitalSignsImpl(
      {this.heartRate,
      this.respiratoryRate,
      required this.quality,
      required this.timestamp});

  factory _$VitalSignsImpl.fromJson(Map<String, dynamic> json) =>
      _$$VitalSignsImplFromJson(json);

  @override
  final int? heartRate;
  @override
  final int? respiratoryRate;
  @override
  final SignalQuality quality;
  @override
  final DateTime timestamp;

  @override
  String toString() {
    return 'VitalSigns(heartRate: $heartRate, respiratoryRate: $respiratoryRate, quality: $quality, timestamp: $timestamp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VitalSignsImpl &&
            (identical(other.heartRate, heartRate) ||
                other.heartRate == heartRate) &&
            (identical(other.respiratoryRate, respiratoryRate) ||
                other.respiratoryRate == respiratoryRate) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, heartRate, respiratoryRate, quality, timestamp);

  /// Create a copy of VitalSigns
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VitalSignsImplCopyWith<_$VitalSignsImpl> get copyWith =>
      __$$VitalSignsImplCopyWithImpl<_$VitalSignsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VitalSignsImplToJson(
      this,
    );
  }
}

abstract class _VitalSigns implements VitalSigns {
  const factory _VitalSigns(
      {final int? heartRate,
      final int? respiratoryRate,
      required final SignalQuality quality,
      required final DateTime timestamp}) = _$VitalSignsImpl;

  factory _VitalSigns.fromJson(Map<String, dynamic> json) =
      _$VitalSignsImpl.fromJson;

  @override
  int? get heartRate;
  @override
  int? get respiratoryRate;
  @override
  SignalQuality get quality;
  @override
  DateTime get timestamp;

  /// Create a copy of VitalSigns
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VitalSignsImplCopyWith<_$VitalSignsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
